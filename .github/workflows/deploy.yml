name: Deploy to AWS

on:
  push:
    branches: [main, master, dev]
  
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - production
          - development
        default: 'development'
      force_deploy:
        description: 'Force deploy all services (ignore change detection)'
        type: boolean
        default: false

env:
  TERRAFORM_VERSION: '1.6.0'

permissions:
  contents: read
  actions: read
  id-token: write

jobs:
  # Wait for CI to complete and detect changes
  wait-for-ci:
    name: Wait for CI & Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}
      order-service: ${{ steps.changes.outputs.order-service }}
      user-service: ${{ steps.changes.outputs.user-service }}
      terraform: ${{ steps.changes.outputs.terraform }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Wait for CI workflow
        if: github.event_name == 'push'
        uses: lewagon/wait-on-check-action@v1.3.4
        with:
          ref: ${{ github.sha }}
          check-regexp: '^(Backend|Frontend|Order Service|User Service|Terraform|CI Summary)$'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10
          allowed-conclusions: success,skipped
      
      - name: Detect changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            backend:
              - 'be/**'
            frontend:
              - 'fe/**'
            order-service:
              - 'order-service/**'
            user-service:
              - 'user-service/**'
            terraform:
              - 'terraform/**'
      
      - name: Summary
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "CI workflow completed successfully"
          else
            echo "Manual deployment triggered"
          fi
          echo "Changes detected:"
          echo "- Backend: ${{ steps.changes.outputs.backend }}"
          echo "- Frontend: ${{ steps.changes.outputs.frontend }}"
          echo "- Order Service: ${{ steps.changes.outputs.order-service }}"
          echo "- User Service: ${{ steps.changes.outputs.user-service }}"
          echo "- Terraform: ${{ steps.changes.outputs.terraform }}"

  # Deploy infrastructure
  deploy-infrastructure:
    name: Deploy Infrastructure
    needs: [wait-for-ci]
    if: |
      always() && !cancelled() &&
      needs.wait-for-ci.result == 'success' &&
      (needs.wait-for-ci.outputs.terraform == 'true' || github.event.inputs.force_deploy == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    defaults:
      run:
        working-directory: terraform/environments/${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'prod' || 'dev') }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}
      
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
      
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Validate
        run: terraform validate
      
      - name: Terraform Plan
        run: |
          terraform plan \
            -var="aws_region=${{ vars.AWS_REGION || 'us-east-1' }}" \
            -var="environment=${{ vars.ENVIRONMENT || 'development' }}" \
            -var="vpc_cidr=${{ vars.VPC_CIDR || '10.0.0.0/16' }}" \
            -var="cluster_name=${{ vars.CLUSTER_NAME || 'sweetdream-cluster' }}" \
            -var="db_name=${{ vars.DB_NAME || 'sweetdream' }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="db_username=${{ secrets.DB_USERNAME || 'postgres' }}" \
            -var="s3_bucket_name=${{ vars.S3_BUCKET_NAME }}" \
            -var="alert_email=${{ secrets.ALERT_EMAIL || 'admin@example.com' }}" \
            -var="log_retention_days=${{ vars.LOG_RETENTION_DAYS || '7' }}" \
            -out=tfplan
      
      - name: Terraform Apply
        run: |
          terraform apply -auto-approve tfplan
          
          echo "## Infrastructure Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "VPC, ECS Cluster, RDS, ALB, and all modules deployed" >> $GITHUB_STEP_SUMMARY

  # Check if this is initial deployment (no services exist)
  check-initial-deployment:
    name: Check Initial Deployment
    needs: [deploy-infrastructure]
    if: |
      always() && !cancelled() &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      is_initial: ${{ steps.check.outputs.is_initial }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
      
      - name: Check if services exist
        id: check
        run: |
          CLUSTER_NAME="sweetdream-cluster"
          
          # Determine service prefix based on environment
          if [[ "${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" == "production" ]]; then
            SERVICE_PREFIX="sweetdream-prod-service"
          else
            SERVICE_PREFIX="sweetdream-dev-service"
          fi
          
          # Check if any service exists
          SERVICES=("backend" "frontend" "order-service" "user-service")
          EXISTING_COUNT=0
          
          for service in "${SERVICES[@]}"; do
            SERVICE_INFO=$(aws ecs describe-services \
              --cluster $CLUSTER_NAME \
              --services $SERVICE_PREFIX-$service \
              --query 'services[0].status' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            
            if [ "$SERVICE_INFO" != "NOT_FOUND" ] && [ "$SERVICE_INFO" != "None" ]; then
              EXISTING_COUNT=$((EXISTING_COUNT + 1))
              echo "Found: $SERVICE_PREFIX-$service (Status: $SERVICE_INFO)"
            fi
          done
          
          echo "Existing services: $EXISTING_COUNT/4"
          
          # If less than 4 services exist, this is initial or incomplete deployment
          if [ $EXISTING_COUNT -lt 4 ]; then
            echo "is_initial=true" >> $GITHUB_OUTPUT
            echo "Initial/Incomplete deployment detected - will deploy all services" >> $GITHUB_STEP_SUMMARY
          else
            echo "is_initial=false" >> $GITHUB_OUTPUT
            echo "All services exist - will use change detection" >> $GITHUB_STEP_SUMMARY
          fi

  # Build and deploy services
  deploy-services:
    name: Deploy Services
    needs: [wait-for-ci, deploy-infrastructure, check-initial-deployment]
    if: |
      always() && !cancelled() &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      (needs.wait-for-ci.outputs.backend == 'true' ||
       needs.wait-for-ci.outputs.frontend == 'true' ||
       needs.wait-for-ci.outputs.order-service == 'true' ||
       needs.wait-for-ci.outputs.user-service == 'true' ||
       needs.check-initial-deployment.outputs.is_initial == 'true' ||
       github.event.inputs.force_deploy == 'true')
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    strategy:
      matrix:
        service:
          - name: backend
            path: be
            port: 3001
          - name: frontend
            path: fe
            port: 3000
          - name: order-service
            path: order-service
            port: 3002
          - name: user-service
            path: user-service
            port: 3003
      fail-fast: false
    steps:
      - name: Check if deployment needed
        id: check
        run: |
          IS_INITIAL="${{ needs.check-initial-deployment.outputs.is_initial }}"
          SERVICE_NAME="${{ matrix.service.name }}"
          
          # Get changed status for this service
          case "$SERVICE_NAME" in
            "backend")
              CHANGED="${{ needs.wait-for-ci.outputs.backend }}"
              ;;
            "frontend")
              CHANGED="${{ needs.wait-for-ci.outputs.frontend }}"
              ;;
            "order-service")
              CHANGED="${{ needs.wait-for-ci.outputs.order-service }}"
              ;;
            "user-service")
              CHANGED="${{ needs.wait-for-ci.outputs.user-service }}"
              ;;
            *)
              CHANGED="false"
              ;;
          esac
          
          if [[ "$IS_INITIAL" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "Deploying $SERVICE_NAME (initial deployment)"
          elif [[ "$CHANGED" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "Deploying $SERVICE_NAME (code changed)"
          elif [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "Deploying $SERVICE_NAME (forced)"
          else
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "Skipping $SERVICE_NAME (no changes)"
          fi
      
      - uses: actions/checkout@v4
        if: steps.check.outputs.deploy == 'true'
        with:
          ref: ${{ github.sha }}
      
      - uses: aws-actions/configure-aws-credentials@v4
        if: steps.check.outputs.deploy == 'true'
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
      
      - uses: aws-actions/amazon-ecr-login@v2
        if: steps.check.outputs.deploy == 'true'
        id: ecr
      
      - name: Get ALB URL
        if: steps.check.outputs.deploy == 'true' && matrix.service.name == 'frontend'
        id: alb
        run: |
          ALB_URL=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `sweetdream`)].DNSName' \
            --output text)
          echo "url=$ALB_URL" >> $GITHUB_OUTPUT
      
      - name: Build & Push Docker Image
        if: steps.check.outputs.deploy == 'true'
        env:
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE_NAME=$ECR_REGISTRY/sweetdream-${{ matrix.service.name }}
          
          # Build with appropriate args
          if [[ "${{ matrix.service.name }}" == "frontend" ]]; then
            docker build \
              --build-arg NEXT_PUBLIC_API_URL=http://${{ steps.alb.outputs.url }} \
              -t $IMAGE_NAME:latest \
              -t $IMAGE_NAME:$IMAGE_TAG \
              ./${{ matrix.service.path }}
          else
            docker build \
              -t $IMAGE_NAME:latest \
              -t $IMAGE_NAME:$IMAGE_TAG \
              ./${{ matrix.service.path }}
          fi
          
          # Push both tags
          docker push $IMAGE_NAME:latest
          docker push $IMAGE_NAME:$IMAGE_TAG
          
          echo "Pushed ${{ matrix.service.name }}:$IMAGE_TAG" >> $GITHUB_STEP_SUMMARY

  # Update task definitions with Terraform after images are pushed
  update-task-definitions:
    name: Update Task Definitions
    needs: [wait-for-ci, deploy-services, check-initial-deployment]
    if: |
      always() && !cancelled() &&
      needs.deploy-services.result == 'success'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    defaults:
      run:
        working-directory: terraform/environments/${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'prod' || 'dev') }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}
      
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
      
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Apply (Update Task Definitions)
        run: |
          terraform apply -auto-approve \
            -var="aws_region=${{ vars.AWS_REGION || 'us-east-1' }}" \
            -var="environment=${{ vars.ENVIRONMENT || 'development' }}" \
            -var="vpc_cidr=${{ vars.VPC_CIDR || '10.0.0.0/16' }}" \
            -var="cluster_name=${{ vars.CLUSTER_NAME || 'sweetdream-cluster' }}" \
            -var="db_name=${{ vars.DB_NAME || 'sweetdream' }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="db_username=${{ secrets.DB_USERNAME || 'postgres' }}" \
            -var="s3_bucket_name=${{ vars.S3_BUCKET_NAME }}" \
            -var="alert_email=${{ secrets.ALERT_EMAIL || 'admin@example.com' }}" \
            -var="log_retention_days=${{ vars.LOG_RETENTION_DAYS || '7' }}"
          
          echo "Task definitions updated with new ECR images" >> $GITHUB_STEP_SUMMARY

  # Force ECS to use updated task definitions
  redeploy-services:
    name: Redeploy Services
    needs: [wait-for-ci, update-task-definitions, check-initial-deployment]
    if: |
      always() && !cancelled() &&
      needs.update-task-definitions.result == 'success'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    strategy:
      matrix:
        service:
          - name: backend
          - name: frontend
          - name: order-service
          - name: user-service
      fail-fast: false
    steps:
      - name: Check if deployment needed
        id: check
        run: |
          IS_INITIAL="${{ needs.check-initial-deployment.outputs.is_initial }}"
          SERVICE_NAME="${{ matrix.service.name }}"
          
          # Get changed status for this service
          case "$SERVICE_NAME" in
            "backend")
              CHANGED="${{ needs.wait-for-ci.outputs.backend }}"
              ;;
            "frontend")
              CHANGED="${{ needs.wait-for-ci.outputs.frontend }}"
              ;;
            "order-service")
              CHANGED="${{ needs.wait-for-ci.outputs.order-service }}"
              ;;
            "user-service")
              CHANGED="${{ needs.wait-for-ci.outputs.user-service }}"
              ;;
            *)
              CHANGED="false"
              ;;
          esac
          
          if [[ "$IS_INITIAL" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
          elif [[ "$CHANGED" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
          else
            echo "deploy=false" >> $GITHUB_OUTPUT
          fi
      
      - uses: aws-actions/configure-aws-credentials@v4
        if: steps.check.outputs.deploy == 'true'
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
      
      - name: Deploy to ECS
        if: steps.check.outputs.deploy == 'true'
        run: |
          # Determine service name based on environment
          if [[ "${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" == "production" ]]; then
            SERVICE_NAME="sweetdream-prod-service-${{ matrix.service.name }}"
          else
            SERVICE_NAME="sweetdream-dev-service-${{ matrix.service.name }}"
          fi
          
          CLUSTER_NAME="sweetdream-cluster"
          
          echo "Checking if $SERVICE_NAME exists..."
          
          # Get service info
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0].{status:status,runningCount:runningCount,desiredCount:desiredCount}' \
            --output json 2>/dev/null || echo '{"status":"NOT_FOUND"}')
          
          echo "Service info: $SERVICE_INFO"
          
          SERVICE_STATUS=$(echo $SERVICE_INFO | jq -r '.status // "NOT_FOUND"')
          RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount // 0')
          DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount // 0')
          
          if [ "$SERVICE_STATUS" = "NOT_FOUND" ] || [ "$SERVICE_STATUS" = "null" ]; then
            echo "Service $SERVICE_NAME does not exist. Skipping deployment."
            echo "$SERVICE_NAME: Service not found (may need initial Terraform apply)" >> $GITHUB_STEP_SUMMARY
          elif [ "$SERVICE_STATUS" = "ACTIVE" ]; then
            echo "Service exists and is active. Deploying $SERVICE_NAME..."
            echo "Current state: Running=$RUNNING_COUNT, Desired=$DESIRED_COUNT"
            aws ecs update-service \
              --cluster $CLUSTER_NAME \
              --service $SERVICE_NAME \
              --force-new-deployment \
              --no-cli-pager
            echo "$SERVICE_NAME deployment initiated (Running: $RUNNING_COUNT/$DESIRED_COUNT)" >> $GITHUB_STEP_SUMMARY
          else
            echo "Service exists but status is: $SERVICE_STATUS (Running: $RUNNING_COUNT, Desired: $DESIRED_COUNT)"
            echo "Attempting deployment anyway..."
            aws ecs update-service \
              --cluster $CLUSTER_NAME \
              --service $SERVICE_NAME \
              --force-new-deployment \
              --no-cli-pager
            echo "$SERVICE_NAME deployment initiated (status: $SERVICE_STATUS)" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Wait for deployment
        if: steps.check.outputs.deploy == 'true'
        run: |
          # Determine service name based on environment
          if [[ "${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" == "production" ]]; then
            SERVICE_NAME="sweetdream-prod-service-${{ matrix.service.name }}"
          else
            SERVICE_NAME="sweetdream-dev-service-${{ matrix.service.name }}"
          fi
          
          CLUSTER_NAME="${{ vars.CLUSTER_NAME || 'sweetdream-cluster' }}"
          
          # Get service info
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0].{status:status,desiredCount:desiredCount}' \
            --output json 2>/dev/null || echo '{"status":"NOT_FOUND"}')
          
          SERVICE_STATUS=$(echo $SERVICE_INFO | jq -r '.status // "NOT_FOUND"')
          DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount // 0')
          
          if [ "$SERVICE_STATUS" = "NOT_FOUND" ] || [ "$SERVICE_STATUS" = "null" ]; then
            echo "Skipping wait for $SERVICE_NAME (service not found)"
          elif [ "$DESIRED_COUNT" = "0" ]; then
            echo "Skipping wait for $SERVICE_NAME (desiredCount is 0 - no tasks to run)"
            echo "$SERVICE_NAME: No tasks running (desiredCount=0)" >> $GITHUB_STEP_SUMMARY
          else
            echo "Waiting for $SERVICE_NAME to stabilize (desiredCount=$DESIRED_COUNT)..."
            aws ecs wait services-stable \
              --cluster $CLUSTER_NAME \
              --services $SERVICE_NAME \
              --no-cli-pager
            echo "$SERVICE_NAME is stable" >> $GITHUB_STEP_SUMMARY
          fi

  # Deployment summary
  summary:
    name: Deployment Summary
    needs: [wait-for-ci, deploy-infrastructure, deploy-services]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
      
      - name: Get Deployment Info
        id: info
        run: |
          ALB_URL=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `sweetdream`)].DNSName' \
            --output text)
          echo "alb_url=$ALB_URL" >> $GITHUB_OUTPUT
          
          # Get service statuses
          CLUSTER_NAME="${{ vars.CLUSTER_NAME || 'sweetdream-cluster' }}"
          
          # Determine service prefix based on environment
          if [[ "${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" == "production" ]]; then
            SERVICE_PREFIX="sweetdream-prod-service"
          else
            SERVICE_PREFIX="sweetdream-dev-service"
          fi
          
          SERVICES=("backend" "frontend" "order-service" "user-service")
          for service in "${SERVICES[@]}"; do
            STATUS=$(aws ecs describe-services \
              --cluster $CLUSTER_NAME \
              --services $SERVICE_PREFIX-$service \
              --query 'services[0].deployments[0].rolloutState' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            echo "${service}_status=$STATUS" >> $GITHUB_OUTPUT
          done
      
      - name: Create Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Status" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.deploy-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | ${{ steps.info.outputs.backend_status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ steps.info.outputs.frontend_status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Order Service | ${{ steps.info.outputs.order-service_status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| User Service | ${{ steps.info.outputs.user-service_status }} |" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Access" >> $GITHUB_STEP_SUMMARY
          echo "- **Application URL**: http://${{ steps.info.outputs.alb_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Changes Deployed" >> $GITHUB_STEP_SUMMARY
          echo "- Backend: ${{ needs.wait-for-ci.outputs.backend == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend: ${{ needs.wait-for-ci.outputs.frontend == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Order Service: ${{ needs.wait-for-ci.outputs.order-service == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- User Service: ${{ needs.wait-for-ci.outputs.user-service == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Terraform: ${{ needs.wait-for-ci.outputs.terraform == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
