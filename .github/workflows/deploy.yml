name: Deploy to AWS

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches: [main, master, dev]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - production
          - development
        default: 'development'
      force_deploy:
        description: 'Force deploy all services (ignore change detection)'
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  ECS_CLUSTER: sweetdream-cluster
  TERRAFORM_VERSION: '1.6.0'

permissions:
  contents: read
  actions: read
  id-token: write

jobs:
  # Check CI success (only for workflow_run trigger)
  check-ci:
    name: Check CI Success
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run'
    steps:
      - name: Check CI Result
        run: |
          if [[ "${{ github.event.workflow_run.conclusion }}" != "success" ]]; then
            echo "CI workflow failed or was cancelled. Deployment aborted."
            exit 1
          fi
          echo "CI workflow completed successfully. Proceeding with deployment."

  # Detect changes
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    needs: [check-ci]
    if: always() && (needs.check-ci.result == 'success' || github.event_name == 'workflow_dispatch')
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      order-service: ${{ steps.filter.outputs.order-service }}
      user-service: ${{ steps.filter.outputs.user-service }}
      terraform: ${{ steps.filter.outputs.terraform }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'be/**'
            frontend:
              - 'fe/**'
            order-service:
              - 'order-service/**'
            user-service:
              - 'user-service/**'
            terraform:
              - 'terraform/**'

  # Deploy infrastructure
  deploy-infrastructure:
    name: Deploy Infrastructure
    needs: changes
    if: needs.changes.outputs.terraform == 'true' || github.event.inputs.force_deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    defaults:
      run:
        working-directory: terraform/environments/${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'prod' || 'dev') }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Validate
        run: terraform validate
      
      - name: Cleanup conflicting resources (if analytics enabled)
        if: vars.ENABLE_ANALYTICS == 'true'
        continue-on-error: true
        run: |
          echo "Cleaning up conflicting resources..."
          
          # Only delete if they exist outside Terraform state
          # Check if resources exist in state first
          if ! terraform state list | grep -q "module.backend_analytics"; then
            echo "Resources not in state, cleaning up manually created ones..."
            
            # Delete CloudWatch query definitions that conflict
            QUERIES=$(aws logs describe-query-definitions \
              --query 'queryDefinitions[?contains(name, `sweetdream-service`)].queryDefinitionId' \
              --output text 2>/dev/null || echo "")
            
            if [ ! -z "$QUERIES" ]; then
              echo "Found conflicting CloudWatch queries, deleting..."
              for query_id in $QUERIES; do
                aws logs delete-query-definition --query-definition-id "$query_id" 2>/dev/null || true
              done
            fi
            
            # Delete IAM roles if they exist
            aws iam delete-role-policy \
              --role-name sweetdream-service-backend-export-lambda-role \
              --policy-name sweetdream-service-backend-export-lambda-policy \
              2>/dev/null || true
            
            aws iam delete-role \
              --role-name sweetdream-service-backend-export-lambda-role \
              2>/dev/null || true
            
            aws iam delete-role-policy \
              --role-name sweetdream-service-order-service-export-lambda-role \
              --policy-name sweetdream-service-order-service-export-lambda-policy \
              2>/dev/null || true
            
            aws iam delete-role \
              --role-name sweetdream-service-order-service-export-lambda-role \
              2>/dev/null || true
            
            echo "Cleanup complete, waiting 10 seconds..."
            sleep 10
          else
            echo "Resources already in Terraform state, skipping cleanup"
          fi
      
      - name: Terraform Plan
        run: |
          terraform plan \
            -var="aws_region=${{ vars.AWS_REGION || 'us-east-1' }}" \
            -var="environment=${{ vars.ENVIRONMENT || 'development' }}" \
            -var="vpc_cidr=${{ vars.VPC_CIDR || '10.0.0.0/16' }}" \
            -var="cluster_name=${{ vars.CLUSTER_NAME || 'sweetdream-cluster' }}" \
            -var="db_name=${{ vars.DB_NAME || 'sweetdream' }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="db_username=${{ secrets.DB_USERNAME || 'postgres' }}" \
            -var="s3_bucket_name=${{ vars.S3_BUCKET_NAME }}" \
            -var="alert_email=${{ secrets.ALERT_EMAIL || 'admin@example.com' }}" \
            -var="log_retention_days=${{ vars.LOG_RETENTION_DAYS || '7' }}" \
            -out=tfplan
      
      - name: Terraform Apply
        run: |
          terraform apply -auto-approve tfplan
          
          echo "## Infrastructure Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "VPC, ECS Cluster, RDS, ALB, and all modules deployed" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ vars.ENABLE_ANALYTICS }}" = "true" ]; then
            echo "Analytics Lambda functions deployed" >> $GITHUB_STEP_SUMMARY
          fi

  # Build and deploy services
  deploy-services:
    name: Deploy Services
    needs: [changes, deploy-infrastructure]
    if: |
      always() && !cancelled() &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      (needs.changes.outputs.backend == 'true' || 
       needs.changes.outputs.frontend == 'true' || 
       needs.changes.outputs.order-service == 'true' || 
       needs.changes.outputs.user-service == 'true' ||
       github.event.inputs.force_deploy == 'true')
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    strategy:
      matrix:
        service:
          - name: backend
            path: be
            port: 3001
            changed: ${{ needs.changes.outputs.backend }}
          - name: frontend
            path: fe
            port: 3000
            changed: ${{ needs.changes.outputs.frontend }}
          - name: order-service
            path: order-service
            port: 3002
            changed: ${{ needs.changes.outputs.order-service }}
          - name: user-service
            path: user-service
            port: 3003
            changed: ${{ needs.changes.outputs.user-service }}
      fail-fast: false
    steps:
      - name: Check if deployment needed
        id: check
        run: |
          if [[ "${{ matrix.service.changed }}" == "true" || "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "Deploying ${{ matrix.service.name }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "Skipping ${{ matrix.service.name }} (no changes)" >> $GITHUB_STEP_SUMMARY
          fi
      
      - uses: actions/checkout@v4
        if: steps.check.outputs.deploy == 'true'
      
      - uses: aws-actions/configure-aws-credentials@v4
        if: steps.check.outputs.deploy == 'true'
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - uses: aws-actions/amazon-ecr-login@v2
        if: steps.check.outputs.deploy == 'true'
        id: ecr
      
      - name: Get ALB URL
        if: steps.check.outputs.deploy == 'true' && matrix.service.name == 'frontend'
        id: alb
        run: |
          ALB_URL=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `sweetdream`)].DNSName' \
            --output text)
          echo "url=$ALB_URL" >> $GITHUB_OUTPUT
      
      - name: Build & Push Docker Image
        if: steps.check.outputs.deploy == 'true'
        env:
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE_NAME=$ECR_REGISTRY/sweetdream-${{ matrix.service.name }}
          
          # Build with appropriate args
          if [[ "${{ matrix.service.name }}" == "frontend" ]]; then
            docker build \
              --build-arg NEXT_PUBLIC_API_URL=http://${{ steps.alb.outputs.url }} \
              -t $IMAGE_NAME:latest \
              -t $IMAGE_NAME:$IMAGE_TAG \
              ./${{ matrix.service.path }}
          else
            docker build \
              -t $IMAGE_NAME:latest \
              -t $IMAGE_NAME:$IMAGE_TAG \
              ./${{ matrix.service.path }}
          fi
          
          # Push both tags
          docker push $IMAGE_NAME:latest
          docker push $IMAGE_NAME:$IMAGE_TAG
          
          echo "Pushed ${{ matrix.service.name }}:$IMAGE_TAG" >> $GITHUB_STEP_SUMMARY

  # Update task definitions with Terraform after images are pushed
  update-task-definitions:
    name: Update Task Definitions
    needs: [changes, deploy-services]
    if: |
      always() && !cancelled() &&
      needs.deploy-services.result == 'success'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    defaults:
      run:
        working-directory: terraform/environments/${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'prod' || 'dev') }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Apply (Update Task Definitions)
        run: |
          terraform apply -auto-approve \
            -var="aws_region=${{ vars.AWS_REGION || 'us-east-1' }}" \
            -var="environment=${{ vars.ENVIRONMENT || 'development' }}" \
            -var="vpc_cidr=${{ vars.VPC_CIDR || '10.0.0.0/16' }}" \
            -var="cluster_name=${{ vars.CLUSTER_NAME || 'sweetdream-cluster' }}" \
            -var="db_name=${{ vars.DB_NAME || 'sweetdream' }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="db_username=${{ secrets.DB_USERNAME || 'postgres' }}" \
            -var="s3_bucket_name=${{ vars.S3_BUCKET_NAME }}" \
            -var="alert_email=${{ secrets.ALERT_EMAIL || 'admin@example.com' }}" \
            -var="log_retention_days=${{ vars.LOG_RETENTION_DAYS || '7' }}"
          
          echo "Task definitions updated with new ECR images" >> $GITHUB_STEP_SUMMARY

  # Force ECS to use updated task definitions
  redeploy-services:
    name: Redeploy Services
    needs: [changes, update-task-definitions]
    if: |
      always() && !cancelled() &&
      needs.update-task-definitions.result == 'success'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    strategy:
      matrix:
        service:
          - name: backend
            changed: ${{ needs.changes.outputs.backend }}
          - name: frontend
            changed: ${{ needs.changes.outputs.frontend }}
          - name: order-service
            changed: ${{ needs.changes.outputs.order-service }}
          - name: user-service
            changed: ${{ needs.changes.outputs.user-service }}
      fail-fast: false
    steps:
      - name: Check if deployment needed
        id: check
        run: |
          if [[ "${{ matrix.service.changed }}" == "true" || "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
          else
            echo "deploy=false" >> $GITHUB_OUTPUT
          fi
      
      - uses: aws-actions/configure-aws-credentials@v4
        if: steps.check.outputs.deploy == 'true'
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Deploy to ECS
        if: steps.check.outputs.deploy == 'true'
        run: |
          SERVICE_NAME="sweetdream-service-${{ matrix.service.name }}"
          
          echo "Checking if $SERVICE_NAME exists..."
          
          # Check if service exists and is active
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services $SERVICE_NAME \
            --query 'services[0].status' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
            echo "Service exists and is active. Deploying $SERVICE_NAME..."
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service $SERVICE_NAME \
              --force-new-deployment \
              --no-cli-pager
            echo "$SERVICE_NAME deployment initiated" >> $GITHUB_STEP_SUMMARY
          elif [ "$SERVICE_STATUS" = "NOT_FOUND" ]; then
            echo "Service $SERVICE_NAME does not exist. Skipping deployment."
            echo "$SERVICE_NAME: Service not found (may need initial Terraform apply)" >> $GITHUB_STEP_SUMMARY
          else
            echo "Service $SERVICE_NAME exists but is not active (status: $SERVICE_STATUS). Skipping deployment."
            echo "$SERVICE_NAME: Service not active (status: $SERVICE_STATUS)" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Wait for deployment
        if: steps.check.outputs.deploy == 'true'
        run: |
          SERVICE_NAME="sweetdream-service-${{ matrix.service.name }}"
          
          # Check if service exists before waiting
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services $SERVICE_NAME \
            --query 'services[0].status' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
            echo "Waiting for $SERVICE_NAME to stabilize..."
            aws ecs wait services-stable \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services $SERVICE_NAME \
              --no-cli-pager
            echo "$SERVICE_NAME is stable" >> $GITHUB_STEP_SUMMARY
          else
            echo "Skipping wait for $SERVICE_NAME (service not active)"
          fi

  # Verify analytics deployment
  verify-analytics:
    name: Verify Analytics
    needs: [deploy-infrastructure]
    if: |
      always() && !cancelled() &&
      needs.deploy-infrastructure.result == 'success' &&
      vars.ENABLE_ANALYTICS == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Verify Lambda Functions
        id: verify
        run: |
          echo "Verifying Analytics Lambda deployment..."
          
          BACKEND_LAMBDA=$(aws lambda get-function \
            --function-name sweetdream-service-backend-export-logs \
            --query 'Configuration.FunctionName' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          ORDER_LAMBDA=$(aws lambda get-function \
            --function-name sweetdream-service-order-service-export-logs \
            --query 'Configuration.FunctionName' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          echo "backend_lambda=$BACKEND_LAMBDA" >> $GITHUB_OUTPUT
          echo "order_lambda=$ORDER_LAMBDA" >> $GITHUB_OUTPUT
          
          echo "## Analytics Lambda Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Function | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Backend Export | $BACKEND_LAMBDA |" >> $GITHUB_STEP_SUMMARY
          echo "| Order Export | $ORDER_LAMBDA |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      
      - name: Test Lambda Functions
        if: steps.verify.outputs.backend_lambda != 'NOT_FOUND'
        run: |
          echo "Testing Lambda functions..."
          
          # Test backend Lambda (empty payload - exports today's logs)
          aws lambda invoke \
            --function-name sweetdream-service-backend-export-logs \
            --payload '{}' \
            --cli-binary-format raw-in-base64-out \
            response-backend.json
          
          # Test order Lambda (empty payload - exports today's logs)
          aws lambda invoke \
            --function-name sweetdream-service-order-service-export-logs \
            --payload '{}' \
            --cli-binary-format raw-in-base64-out \
            response-order.json
          
          echo "### Lambda Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Backend:**" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          cat response-backend.json >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Order:**" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          cat response-order.json >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # Deployment summary
  summary:
    name: Deployment Summary
    needs: [changes, deploy-infrastructure, deploy-services, verify-analytics]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get Deployment Info
        id: info
        run: |
          ALB_URL=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `sweetdream`)].DNSName' \
            --output text)
          echo "alb_url=$ALB_URL" >> $GITHUB_OUTPUT
          
          # Get service statuses
          SERVICES=("backend" "frontend" "order-service" "user-service")
          for service in "${SERVICES[@]}"; do
            STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services sweetdream-service-$service \
              --query 'services[0].deployments[0].rolloutState' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            echo "${service}_status=$STATUS" >> $GITHUB_OUTPUT
          done
      
      - name: Check Analytics Status
        id: analytics
        if: vars.ENABLE_ANALYTICS == 'true'
        run: |
          BACKEND_LAMBDA=$(aws lambda get-function \
            --function-name sweetdream-service-backend-export-logs \
            --query 'Configuration.FunctionName' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          ORDER_LAMBDA=$(aws lambda get-function \
            --function-name sweetdream-service-order-service-export-logs \
            --query 'Configuration.FunctionName' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          if [ "$BACKEND_LAMBDA" != "NOT_FOUND" ] && [ "$ORDER_LAMBDA" != "NOT_FOUND" ]; then
            echo "status=Deployed" >> $GITHUB_OUTPUT
          else
            echo "status=Failed" >> $GITHUB_OUTPUT
          fi
      
      - name: Create Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Status" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.deploy-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | ${{ steps.info.outputs.backend_status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ steps.info.outputs.frontend_status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Order Service | ${{ steps.info.outputs.order-service_status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| User Service | ${{ steps.info.outputs.user-service_status }} |" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ vars.ENABLE_ANALYTICS }}" = "true" ]; then
            echo "| Analytics Lambda | ${{ steps.analytics.outputs.status || 'Skipped' }} |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Access" >> $GITHUB_STEP_SUMMARY
          echo "- **Application URL**: http://${{ steps.info.outputs.alb_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Changes Deployed" >> $GITHUB_STEP_SUMMARY
          echo "- Backend: ${{ needs.changes.outputs.backend == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend: ${{ needs.changes.outputs.frontend == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Order Service: ${{ needs.changes.outputs.order-service == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- User Service: ${{ needs.changes.outputs.user-service == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Terraform: ${{ needs.changes.outputs.terraform == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ vars.ENABLE_ANALYTICS }}" = "true" ]; then
            echo "- Analytics: ${{ needs.verify-analytics.result == 'success' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          fi