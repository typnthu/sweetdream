name: Deploy

on:
  push:
    branches: [main, master, dev]
  workflow_dispatch:
    inputs:
      destroy_first:
        description: 'Destroy all resources first (clean slate)'
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  ECS_CLUSTER: sweetdream-cluster

jobs:

  # Deploy everything
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: ${{ (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && 'production' || 'development' }}
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Terraform Init
        run: terraform init
      
      - name: Clear Stale State Lock
        continue-on-error: true
        run: |
          echo "Checking for stale state locks..."
          # Get lock info from DynamoDB
          LOCK_ID=$(aws dynamodb get-item \
            --table-name sweetdream-terraform-locks \
            --key '{"LockID":{"S":"sweetdream-terraform-state-409964509537/terraform.tfstate"}}' \
            --query 'Item.LockID.S' \
            --output text 2>/dev/null || echo "")
          
          if [ ! -z "$LOCK_ID" ] && [ "$LOCK_ID" != "None" ]; then
            echo "Found stale lock, attempting to clear..."
            # Delete the lock item from DynamoDB
            aws dynamodb delete-item \
              --table-name sweetdream-terraform-locks \
              --key '{"LockID":{"S":"sweetdream-terraform-state-409964509537/terraform.tfstate"}}' 2>/dev/null || true
            echo "âœ“ Lock cleared"
          else
            echo "No stale locks found"
          fi
      
      - name: Import Existing S3 Buckets
        continue-on-error: true
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        run: |
          echo "Checking for existing S3 buckets to import..."
          
          # Import backend analytics bucket if it exists and not in state
          if aws s3api head-bucket --bucket "sweetdream-analytics-backend-production" 2>/dev/null; then
            if ! terraform state show 'module.backend_analytics[0].aws_s3_bucket.analytics' &>/dev/null; then
              echo "Importing backend analytics bucket..."
              terraform import -input=false 'module.backend_analytics[0].aws_s3_bucket.analytics' sweetdream-analytics-backend-production || true
            fi
            if ! terraform state show 'module.backend_analytics[0].aws_s3_bucket_versioning.analytics' &>/dev/null; then
              echo "Importing backend bucket versioning..."
              terraform import -input=false 'module.backend_analytics[0].aws_s3_bucket_versioning.analytics' sweetdream-analytics-backend-production || true
            fi
          fi
          
          # Import order analytics bucket if it exists and not in state
          if aws s3api head-bucket --bucket "sweetdream-analytics-order-production" 2>/dev/null; then
            if ! terraform state show 'module.order_analytics[0].aws_s3_bucket.analytics' &>/dev/null; then
              echo "Importing order analytics bucket..."
              terraform import -input=false 'module.order_analytics[0].aws_s3_bucket.analytics' sweetdream-analytics-order-production || true
            fi
            if ! terraform state show 'module.order_analytics[0].aws_s3_bucket_versioning.analytics' &>/dev/null; then
              echo "Importing order bucket versioning..."
              terraform import -input=false 'module.order_analytics[0].aws_s3_bucket_versioning.analytics' sweetdream-analytics-order-production || true
            fi
          fi
          
          echo "âœ“ Import check completed" >> $GITHUB_STEP_SUMMARY
      
      - name: Terraform Apply
        run: |
          terraform plan -out=tfplan -var="db_password=${{ secrets.DB_PASSWORD }}"
          terraform apply -auto-approve tfplan
          echo "âœ“ Infrastructure deployed" >> $GITHUB_STEP_SUMMARY

  # Build and deploy all services
  deploy-services:
    name: Deploy All Services
    needs: [deploy-infrastructure]
    if: always() && !cancelled() && needs.deploy-infrastructure.result == 'success'
    runs-on: ubuntu-latest
    environment: ${{ (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && 'production' || 'development' }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - uses: aws-actions/amazon-ecr-login@v2
        id: ecr
      
      - name: Get ALB URL
        id: alb
        run: |
          ALB_URL=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `sweetdream`)].DNSName' \
            --output text)
          echo "url=$ALB_URL" >> $GITHUB_OUTPUT
      
      - name: Build & Push All Images
        env:
          ECR_REGISTRY: ${{ steps.ecr.outputs.registry }}
          NEXT_PUBLIC_API_URL: http://${{ steps.alb.outputs.url }}
        run: |
          echo "Building all Docker images..."
          
          # Backend
          docker build -t $ECR_REGISTRY/sweetdream-backend:latest ./be
          docker push $ECR_REGISTRY/sweetdream-backend:latest
          echo "Backend pushed"
          
          # Frontend
          docker build --build-arg NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL \
            -t $ECR_REGISTRY/sweetdream-frontend:latest ./fe
          docker push $ECR_REGISTRY/sweetdream-frontend:latest
          echo "Frontend pushed"
          
          # Order Service
          docker build -t $ECR_REGISTRY/sweetdream-order-service:latest ./order-service
          docker push $ECR_REGISTRY/sweetdream-order-service:latest
          echo "Order Service pushed"
          
          # User Service
          docker build -t $ECR_REGISTRY/sweetdream-user-service:latest ./user-service
          docker push $ECR_REGISTRY/sweetdream-user-service:latest
          echo "User Service pushed"
      
      - name: Deploy All Services to ECS
        run: |
          echo "ðŸš€ Deploying all services..."
          
          services=(
            "sweetdream-service-backend"
            "sweetdream-service-frontend"
            "sweetdream-service-order-service"
            "sweetdream-service-user-service"
          )
          
          for service in "${services[@]}"; do
            echo "Deploying: $service"
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service $service \
              --force-new-deployment \
              --no-cli-pager || echo "Service $service not ready yet"
          done
          
          echo "All services deployed" >> $GITHUB_STEP_SUMMARY

  # Summary
  summary:
    name: Deployment Summary
    needs: [deploy-infrastructure, deploy-services]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get Info
        id: info
        run: |
          ALB_URL=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `sweetdream`)].DNSName' \
            --output text)
          echo "alb_url=$ALB_URL" >> $GITHUB_OUTPUT
      
      - name: Create Summary
        run: |
          echo "## ðŸš€ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Status" >> $GITHUB_STEP_SUMMARY
          echo "- Infrastructure: ${{ needs.deploy-infrastructure.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Services: ${{ needs.deploy-services.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Access" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: http://${{ steps.info.outputs.alb_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
